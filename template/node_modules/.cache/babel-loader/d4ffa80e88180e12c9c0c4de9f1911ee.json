{"ast":null,"code":"var Lexer = require('./Lexer.js');\n\nvar Parser = require('./Parser.js');\n\nvar Renderer = require('./Renderer.js');\n\nvar TextRenderer = require('./TextRenderer.js');\n\nvar InlineLexer = require('./InlineLexer.js');\n\nvar Slugger = require('./Slugger.js');\n\nvar _require = require('./helpers.js'),\n    merge = _require.merge,\n    checkSanitizeDeprecation = _require.checkSanitizeDeprecation,\n    escape = _require.escape;\n\nvar _require2 = require('./defaults.js'),\n    getDefaults = _require2.getDefaults,\n    changeDefaults = _require2.changeDefaults,\n    defaults = _require2.defaults;\n/**\n * Marked\n */\n\n\nfunction marked(src, opt, callback) {\n  // throw error in case of non string input\n  if (typeof src === 'undefined' || src === null) {\n    throw new Error('marked(): input parameter is undefined or null');\n  }\n\n  if (typeof src !== 'string') {\n    throw new Error('marked(): input parameter is of type ' + Object.prototype.toString.call(src) + ', string expected');\n  }\n\n  if (callback || typeof opt === 'function') {\n    var _ret = function () {\n      if (!callback) {\n        callback = opt;\n        opt = null;\n      }\n\n      opt = merge({}, marked.defaults, opt || {});\n      checkSanitizeDeprecation(opt);\n      var highlight = opt.highlight;\n      var tokens,\n          pending,\n          i = 0;\n\n      try {\n        tokens = Lexer.lex(src, opt);\n      } catch (e) {\n        return {\n          v: callback(e)\n        };\n      }\n\n      pending = tokens.length;\n\n      var done = function done(err) {\n        if (err) {\n          opt.highlight = highlight;\n          return callback(err);\n        }\n\n        var out;\n\n        try {\n          out = Parser.parse(tokens, opt);\n        } catch (e) {\n          err = e;\n        }\n\n        opt.highlight = highlight;\n        return err ? callback(err) : callback(null, out);\n      };\n\n      if (!highlight || highlight.length < 3) {\n        return {\n          v: done()\n        };\n      }\n\n      delete opt.highlight;\n      if (!pending) return {\n        v: done()\n      };\n\n      for (; i < tokens.length; i++) {\n        (function (token) {\n          if (token.type !== 'code') {\n            return --pending || done();\n          }\n\n          return highlight(token.text, token.lang, function (err, code) {\n            if (err) return done(err);\n\n            if (code == null || code === token.text) {\n              return --pending || done();\n            }\n\n            token.text = code;\n            token.escaped = true;\n            --pending || done();\n          });\n        })(tokens[i]);\n      }\n\n      return {\n        v: void 0\n      };\n    }();\n\n    if (typeof _ret === \"object\") return _ret.v;\n  }\n\n  try {\n    opt = merge({}, marked.defaults, opt || {});\n    checkSanitizeDeprecation(opt);\n    return Parser.parse(Lexer.lex(src, opt), opt);\n  } catch (e) {\n    e.message += '\\nPlease report this to https://github.com/markedjs/marked.';\n\n    if ((opt || marked.defaults).silent) {\n      return '<p>An error occurred:</p><pre>' + escape(e.message + '', true) + '</pre>';\n    }\n\n    throw e;\n  }\n}\n/**\n * Options\n */\n\n\nmarked.options = marked.setOptions = function (opt) {\n  merge(marked.defaults, opt);\n  changeDefaults(marked.defaults);\n  return marked;\n};\n\nmarked.getDefaults = getDefaults;\nmarked.defaults = defaults;\n/**\n * Expose\n */\n\nmarked.Parser = Parser;\nmarked.parser = Parser.parse;\nmarked.Renderer = Renderer;\nmarked.TextRenderer = TextRenderer;\nmarked.Lexer = Lexer;\nmarked.lexer = Lexer.lex;\nmarked.InlineLexer = InlineLexer;\nmarked.inlineLexer = InlineLexer.output;\nmarked.Slugger = Slugger;\nmarked.parse = marked;\nmodule.exports = marked;","map":{"version":3,"sources":["/Users/jyothish/Documents/azia-react-pro/template/demo_1/node_modules/marked/src/marked.js"],"names":["Lexer","require","Parser","Renderer","TextRenderer","InlineLexer","Slugger","merge","checkSanitizeDeprecation","escape","getDefaults","changeDefaults","defaults","marked","src","opt","callback","Error","Object","prototype","toString","call","highlight","tokens","pending","i","lex","e","length","done","err","out","parse","token","type","text","lang","code","escaped","message","silent","options","setOptions","parser","lexer","inlineLexer","output","module","exports"],"mappings":"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","sourcesContent":["const Lexer = require('./Lexer.js');\nconst Parser = require('./Parser.js');\nconst Renderer = require('./Renderer.js');\nconst TextRenderer = require('./TextRenderer.js');\nconst InlineLexer = require('./InlineLexer.js');\nconst Slugger = require('./Slugger.js');\nconst {\n  merge,\n  checkSanitizeDeprecation,\n  escape\n} = require('./helpers.js');\nconst {\n  getDefaults,\n  changeDefaults,\n  defaults\n} = require('./defaults.js');\n\n/**\n * Marked\n */\nfunction marked(src, opt, callback) {\n  // throw error in case of non string input\n  if (typeof src === 'undefined' || src === null) {\n    throw new Error('marked(): input parameter is undefined or null');\n  }\n  if (typeof src !== 'string') {\n    throw new Error('marked(): input parameter is of type '\n      + Object.prototype.toString.call(src) + ', string expected');\n  }\n\n  if (callback || typeof opt === 'function') {\n    if (!callback) {\n      callback = opt;\n      opt = null;\n    }\n\n    opt = merge({}, marked.defaults, opt || {});\n    checkSanitizeDeprecation(opt);\n    const highlight = opt.highlight;\n    let tokens,\n      pending,\n      i = 0;\n\n    try {\n      tokens = Lexer.lex(src, opt);\n    } catch (e) {\n      return callback(e);\n    }\n\n    pending = tokens.length;\n\n    const done = function(err) {\n      if (err) {\n        opt.highlight = highlight;\n        return callback(err);\n      }\n\n      let out;\n\n      try {\n        out = Parser.parse(tokens, opt);\n      } catch (e) {\n        err = e;\n      }\n\n      opt.highlight = highlight;\n\n      return err\n        ? callback(err)\n        : callback(null, out);\n    };\n\n    if (!highlight || highlight.length < 3) {\n      return done();\n    }\n\n    delete opt.highlight;\n\n    if (!pending) return done();\n\n    for (; i < tokens.length; i++) {\n      (function(token) {\n        if (token.type !== 'code') {\n          return --pending || done();\n        }\n        return highlight(token.text, token.lang, function(err, code) {\n          if (err) return done(err);\n          if (code == null || code === token.text) {\n            return --pending || done();\n          }\n          token.text = code;\n          token.escaped = true;\n          --pending || done();\n        });\n      })(tokens[i]);\n    }\n\n    return;\n  }\n  try {\n    opt = merge({}, marked.defaults, opt || {});\n    checkSanitizeDeprecation(opt);\n    return Parser.parse(Lexer.lex(src, opt), opt);\n  } catch (e) {\n    e.message += '\\nPlease report this to https://github.com/markedjs/marked.';\n    if ((opt || marked.defaults).silent) {\n      return '<p>An error occurred:</p><pre>'\n        + escape(e.message + '', true)\n        + '</pre>';\n    }\n    throw e;\n  }\n}\n\n/**\n * Options\n */\n\nmarked.options =\nmarked.setOptions = function(opt) {\n  merge(marked.defaults, opt);\n  changeDefaults(marked.defaults);\n  return marked;\n};\n\nmarked.getDefaults = getDefaults;\n\nmarked.defaults = defaults;\n\n/**\n * Expose\n */\n\nmarked.Parser = Parser;\nmarked.parser = Parser.parse;\n\nmarked.Renderer = Renderer;\nmarked.TextRenderer = TextRenderer;\n\nmarked.Lexer = Lexer;\nmarked.lexer = Lexer.lex;\n\nmarked.InlineLexer = InlineLexer;\nmarked.inlineLexer = InlineLexer.output;\n\nmarked.Slugger = Slugger;\n\nmarked.parse = marked;\n\nmodule.exports = marked;\n"]},"metadata":{},"sourceType":"script"}